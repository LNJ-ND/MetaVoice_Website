---
title: "Testing"
author: "Louise"
date: "7/10/2020"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
data <- metavoice_data %>% filter(short_name == "rhd_weed_2020")

View(data)

#input moderators
input_moderators <- NULL #has to go in like this c("method", "dependent_measure")

#filters them, but keeps a list: "speaker"     "speech_type"
categorical_mods <-
  keep(input_moderators, function(mod) { ##??????
    # assumes all derived fields are non-categorical, which may change?
    !(mod %in% fields_derived$field) &&
      keep(fields, ~.x$field == mod)[[1]]$type %in% c("string", "options")
  })

#adds them all together, if no moderator it becomes "all_mod": speaker_speech_type"
mod_group <- if (length(categorical_mods)) { #if it has a length collaps the moderators with _, otherwise its all mod
  paste(categorical_mods, collapse = "_")
} else {
  "all_mod"
}
mod_group

#FUNCTION: if we have moderators, and it's more than 1: go into data and create something with "speaker_speech_type",
#by pasting from/to the categorical_mods ("speaker" "speech_type")
combine_mods <- function(df, cols) {
  if (mod_group != "all_mod" && length(cols) > 1) {
    df[[mod_group]] <- do.call(paste, c(map(cols, ~df[[.x]]), sep = "\n"))
  }
  df
}
dots <- if (is.null(input_moderators)) {
  NULL #if no moderators, then dots = NULL
} else {
  sprintf("!is.na(%s)", input_moderators)
}

mod_data_2 <- data %>%
  filter_(.dots = dots) %>%
  combine_mods(categorical_mods)

View(mod_data)

# test <- mod_data %>% 
#   group_by(task_type) %>% 
#   summarise(
#     mean = mean(d_calc))
#   )

plt_data <- mod_data
mod_factor <- factor(plt_data$speaker_speech_type) #makes the mod group column a factor
plt_data <- factor(plt_data[[mod_group]], #make the moderators factors, reverse the levels
                   levels = rev(levels(mod_factor)))

View(plt_data)
levels(factor(plt_data$speaker_speech_type))


#models
testmodel <- metafor::rma.mv(
  yi = data$d_calc,
  V = data$d_var_calc,
  random = ~ 1 | data[["short_cite"]] /data[["same_infant_calc"]]/data[["unique_row"]],
  slab = make.unique(data[["short_cite"]]),
  method = "REML")
f_t <- fitted(testmodel) # the estimate from running the model distributed on studies (but it is the same number to all of these studies)
f_t
p_t <- predict(testmodel)
p_t

# for forest plot
alpha <- .05
df_leftjoin_sep <- data.frame(effects = as.numeric(testmodel$yi.f),
                              variances = testmodel$vi.f,
                              stringsAsFactors = FALSE) %>%
  mutate(effects.cil = effects - qnorm(alpha / 2, lower.tail = FALSE) * sqrt(variances),
         effects.cih = effects + qnorm(alpha / 2, lower.tail = FALSE) * sqrt(variances),
         estimate = as.numeric(f_t), # from the fitted() - takes the estimates/es
         short_cite = names(f_t), # from the fitted() - takes the names/authors
         estimate.cil = p_t$ci.lb, # from the predict() - the lower boundary
         estimate.cih = p_t$ci.ub, # from the predict() - the upper boundary
         inverse_vars = 1/variances, # 1 divided by the variances (from the model)
         identity = 1)
View(mod_data)
mod_data_t <- mutate(mod_data, short_cite = make.unique(short_cite))
left_join(mutate(mod_data, short_cite = make.unique(short_cite)))
View(df_leftjoin)
##predictors
predictors <- data_frame(moderator = "", value = "", predictor = "intrcpt",
                         print_predictor = "intercept")
predictors
mod_vals <- map_df(categorical_mods, ~data_frame(moderator = .x, value = unique(mod_data[[.x]]))) %>%
  mutate(predictor = paste0(moderator, value), print_predictor = sprintf("%s: %s", moderator, value))
View(mod_vals)

predictors <- predictors %>%
  bind_rows(mod_vals)
predictors
```

